---
title: "Project 1"
output: html_document
date: "2022-09-27"
---
```{r}
library(caret)
library(xgboost)
library(hash)
```

```{r}
# Get data
data <- read.csv("data/Ames_data.csv")
testIDs <- read.table("data/project1_testIDs.dat")

# Drop unwanted columns
drop <- c('Street', 'Utilities', 'Condition_2', 'Roof_Matl', 'Heating', 'Pool_QC', 'Misc_Feature', 'Low_Qual_Fin_SF', 'Pool_Area', 'Longitude','Latitude')
housingData = data[,!(names(data) %in% drop)]

# Set NA values to 0
housingData[is.na(housingData)] = 0

# Create train and test datasets
j <- 2
train <- housingData[-testIDs[,j], ]
test <- housingData[testIDs[,j], ]
test.y <- test[, c(1, 72)]
test <- test[, -72]
write.csv(train,"data/train.csv",row.names=FALSE)
write.csv(test, "data/test.csv",row.names=FALSE)
write.csv(test.y,"data/test_y.csv",row.names=FALSE)
```

```{r}
# Preprocessing
x_train_drop <- c('PID','Sale_Price')
train.x  = train[,!(names(train) %in% x_train_drop)] # train data without "PID" and "Sale_Price"
train.y = log(train['Sale_Price'])# log transformed "Sale_Price"

# Process train data
categorical.vars <- colnames(train.x)[
  which(sapply(train.x,
                 function(x) mode(x)=="character"))]
train.matrix <- train.x[, !colnames(train.x) %in% categorical.vars, 
                          drop=FALSE]
n.train <- nrow(train.matrix)

train_levels <- list()

#Save train.x levels to compare with test.x levels later
for(var in categorical.vars){
    mylevels <- sort(unique(train.x[, var]))
    train_levels <- c(train_levels, mylevels)
    m <- length(mylevels)
    m <- ifelse(m>2, m, 1)
    tmp.train <- matrix(0, n.train, m)
    col.names <- NULL
    for(j in 1:m){
      tmp.train[train.x[, var]==mylevels[j], j] <- 1
      col.names <- c(col.names, paste(var, '_', mylevels[j], sep=''))
      }
    colnames(tmp.train) <- col.names
    train.matrix <- cbind(train.matrix, tmp.train)
}


# Process test data
x_test_drop <- 'PID'
test.x = test[,!(names(test) %in% x_test_drop)] # test data without "PID" and "Sale_Price"

test_categorical.vars <- colnames(train.x)[
which(sapply(train.x, function(x) mode(x)=="character"))]

test.matrix <- train.x[, !colnames(train.x) %in% test_categorical.vars, 
                          drop=FALSE]
n.test <- nrow(test.matrix)

for(var in categorical.vars){
    testlevels <- sort(unique(test.x[, var]))
    m <- length(testlevels)
    m <- ifelse(m>2, m, 1)
    tmp.test <- matrix(0, n.test, m)
    col.names <- NULL
    for(j in 1:m){
      tmp.test[test.x[, var]==testlevels[j], j] <- 1
      col.names <- c(col.names, paste(var, '_', testlevels[j], sep=''))
      }
    colnames(tmp.test) <- col.names
    test.matrix <- cbind(test.matrix, tmp.test)
}

# We need to match the columns for train.matrix to test.matrix. 
# If there is a column in train.matrix that isnt in test.matrix create the column with all 0 values in the test.matrix. 
# If there is a column in test.matrix that is not in train.matrix remove that column from test.matrix. 
# Columns have to be the same order for both

test_cols_set <- hash(colnames(test.matrix),(1:length(colnames(test.matrix))) ) 
train_col_names = colnames(train.matrix)


new_cols = c()
for (i in 1:length(colnames(train.matrix))){
  if(has.key(train_col_names[i],test_cols_set) == TRUE){
    
  }
   # test_cols_set.has.key(train.matrix[1,i])
}



# Remember to set a seed so we can reproduce your results; 
# the seed does not need to be related to your UIN. 
set.seed(1852)
xgb.model <- xgboost(data = as.matrix(train.matrix), 
                       label = as.matrix(train.y), max_depth = 6,
                       eta = 0.05, nrounds = 5000,
                       subsample = 0.5,
                       verbose = FALSE)

predict(xgb.model, as.matrix(test))


```

```{r}

```

